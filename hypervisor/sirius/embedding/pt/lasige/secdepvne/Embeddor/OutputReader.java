package net.floodlightcontroller.sirius.embedding.pt.lasige.secdepvne.Embeddor;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;

/**
 * Class responsible for creating the simplified output 
 * @authors Luis Ferrolho, fc41914, Max Alaluna, fc47349, Faculdade de Ciencias da Universidade de Lisboa
 *
 */
public class OutputReader {
	
	private ConfigsReader cr;
	
	/**
	 * 
	 * @param cr Configurations reader. Important here since it holds the information read from the configurations file passed by the virtualizer. 
	 */
	public OutputReader(ConfigsReader cr) {
		this.cr = cr;
	}
	
	/**
	 * Reads the file outputFile and generates a smplout file with concise information
	 * To add more info uncomment the chain if - else if or add more else if blocks
	 * @param outputFile The output file generated by GLPK with all the information
	 * @param simplifiedOutputFile The smplout to where we should write the concise information
	 * @throws IOException When error reading or writing from/to files
	 */
	public void generateSimplifiedOutput(String outputFile, String simplifiedOutputFile) throws IOException {
		
		String line = null;
		String[] parts = null, parts2 = null;
		
		FileReader fileReader = new FileReader(outputFile);
		BufferedReader bufferedReader = new BufferedReader(fileReader);
		
		FileWriter fileWriter = new FileWriter(simplifiedOutputFile);
		BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
		
		Hashtable<String, ArrayList<String>> workingPaths = new Hashtable<>();
		Hashtable<String, ArrayList<String>> backupPaths = new Hashtable<>();

		while( (line = bufferedReader.readLine()) != null && !line.isEmpty()) {
			parts = line.split(" +");
			
			// Don't need lines with one word or less
			if(parts.length < 2)
				continue;
			
			// Put info in the smplout file
			if(parts[1].contains("thetaw[") && !parts[2].equalsIgnoreCase("0")){
				parts2 = line.split("\\[|\\]|,");
				bufferedWriter.write("Working node of "+parts2[1]+" -> "+parts2[2]+"\n");
			}
			else if(parts[1].contains("thetab[") && !parts[2].equalsIgnoreCase("0")){
				parts2 = line.split("\\[|\\]|,");
				bufferedWriter.write("Backup node of "+parts2[1]+" -> "+parts2[2]+"\n");
			}
			else if((parts[1].contains("fw[") && !parts[2].equalsIgnoreCase("0.000000"))){
				parts2 = line.split("\\[|\\]|,");
				if(cr.getsLinks().contains("("+parts2[3]+","+parts2[4]+")") ||
					cr.getsLinks().contains("("+parts2[4]+","+parts2[3]+")")){
					
					if(!workingPaths.containsKey("("+parts2[1]+","+parts2[2]+")"))
							workingPaths.put("("+parts2[1]+","+parts2[2]+")", new ArrayList<String>());
							
					workingPaths.get("("+parts2[1]+","+parts2[2]+")").add("("+parts2[3]+","+parts2[4]+")");
				}
			}else if((parts[1].contains("fb[") && !parts[2].equalsIgnoreCase("0.000000"))){
				parts2 = line.split("\\[|\\]|,");
				if(cr.getsLinks().contains("("+parts2[3]+","+parts2[4]+")") || 
					cr.getsLinks().contains("("+parts2[4]+","+parts2[3]+")")){
					
					if(!backupPaths.containsKey("("+parts2[1]+","+parts2[2]+")"))
						backupPaths.put("("+parts2[1]+","+parts2[2]+")", new ArrayList<String>());
							
					backupPaths.get("("+parts2[1]+","+parts2[2]+")").add("("+parts2[3]+","+parts2[4]+")");
				}
			}
		}
		
		writePath(bufferedWriter, workingPaths, "Working");
		writePath(bufferedWriter, backupPaths, "Backup");
		
		bufferedReader.close();
		bufferedWriter.close();
		
	}
	
	/**
	 * Method that writes in the smplout file the working and backups substrate links allocated to each virtual link
	 * and the working and backups substrate paths to each virtual link in a simplified way
	 * @param bufferedWriter Entity that writes to the smplout file
	 * @param paths Structure with the virtual links and the respective substrate links mapped to them
	 * @param type Type can be working or backup. This should be in accordance with the structure paths (if it carries working or backup info)
	 * @throws IOException When error writing to files
	 */
	private void writePath(BufferedWriter bufferedWriter, Hashtable<String, ArrayList<String>> paths, String type) throws IOException {
		
		String[] parts = null, parts2 = null;
		Iterator<String> itr = paths.keySet().iterator();
		
		LinkedList<String> listOfLinks = new LinkedList<>();
		
		// Iterate over the vLinks and put the respective allocated substrate links in an ordered way
		// in listOfLinks
		while(itr.hasNext()){
			String vLink = itr.next();
			
			// Run over the list of substrate links while they are not all in listOfLinks
			while(listOfLinks.size() != paths.get(vLink).size()){

				for(int i = 0; i < paths.get(vLink).size(); i++){

					// Try to put the substrate link in the list only if its not there already
					if(!listOfLinks.contains(paths.get(vLink).get(i))){

						if(listOfLinks.size() == 0)
							listOfLinks.add(paths.get(vLink).get(i));
						else{


							parts = paths.get(vLink).get(i).split("\\(|\\)|,");
							parts2 = listOfLinks.getFirst().split("\\(|\\)|,");

							// Check if the new substrate link visited should appear before the current 
							// first pair in the list or after the current last pair
							if(!parts[2].equals(parts2[1]) && !parts[1].equals(parts2[1])) {
								parts2 = listOfLinks.getLast().split("\\(|\\)|,");
							}

							// If all endpoints are different then we can't put them one after another
							if(!parts[2].equals(parts2[1]) && !parts[1].equals(parts2[1]) && 
							   !parts[1].equals(parts2[2]) && !parts[2].equals(parts2[2]))
								continue;

							// Rearrange the pair
							if(parts[1].equals(parts2[1]) || parts[2].equals(parts2[2])){
								String tmp = parts[1];
								parts[1] = parts[2];
								parts[2] = tmp;
							}

							// Add the substrate link
							if(parts2[1].equals(parts[2]))
								listOfLinks.addFirst("("+parts[1]+","+parts[2]+")");
							else if(parts2[2].equals(parts[1]))
								listOfLinks.addLast("("+parts[1]+","+parts[2]+")");
						}
					}
				}
			}
			
			// Write the list of susbtrate links allocated to vLink in smplout file
			bufferedWriter.write(type+" links for "+vLink+" -> ");
			for(String s: listOfLinks)
				bufferedWriter.write(s+" ");
			bufferedWriter.write("\n");
			
			// Write the path allocated to vLink in smplout file
			bufferedWriter.write(type+" path for "+vLink+" -> ");
			for(int i = 0; i < listOfLinks.size(); i++){
				if(i == 0){
					parts = listOfLinks.get(i).split("\\(|\\)|,");
					bufferedWriter.write(parts[1]+" "+parts[2]+" ");
				}else{
					parts = listOfLinks.get(i).split("\\(|\\)|,");
					bufferedWriter.write(parts[2]+" ");
				}
			}
			bufferedWriter.write("\n");
			
			// Clear the listoflinks to go to the next vlinks 
			// and order its allocated substrate links
			listOfLinks.clear();
		}
	}
	
	/**
	 * Check if a request was accepted or not
	 * @param outputFile The output file that holds the result for a certain request
	 * @return true if the request was accepted, false otherwise
	 * @throws IOException When it is impossible to read the file
	 */
	public boolean wasAccepted(String outputFile) throws IOException {
		String line = null;
		boolean wasAccepted = true;
		
		FileReader fileReader = new FileReader(outputFile);
		BufferedReader bufferedReader = new BufferedReader(fileReader);

		while( (line = bufferedReader.readLine()) != null && !line.isEmpty() && wasAccepted) {
			
			// Types of request denial
			if(line.equals("PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION") || 
			   line.equals("PROBLEM HAS NO INTEGER FEASIBLE SOLUTION") || 
			   line.equals("LP HAS NO PRIMAL FEASIBLE SOLUTION"))
				wasAccepted = false;
		}
		
		bufferedReader.close();
		
		return wasAccepted;
	}
}
